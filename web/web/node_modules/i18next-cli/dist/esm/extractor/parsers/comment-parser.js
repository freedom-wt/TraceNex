function e(e,u,i,d){const f=new RegExp("\\bt\\s*\\(\\s*(['\"])([^'\"]+)\\1","g"),p=(i.extract.preservePatterns||[]).map(c),y=function(e){const t=[],n=new Set,s=/\/\/(.*)|\/\*([\s\S]*?)\*\//g;let a;for(;null!==(a=s.exec(e));){const e=(a[1]??a[2]).trim();e&&!n.has(e)&&(n.add(e),t.push(e))}return t}(e);for(const e of y){let c;for(;null!==(c=f.exec(e));){let f,y=c[2];if(!y||""===y.trim())continue;if(p.some(e=>e.test(y)))continue;const $=e.slice(c.index+c[0].length),x=s($),h=r($),g=o($),m=l($);let V=!1;const k=i.extract.pluralSeparator??"_";if(y.endsWith(`${k}ordinal`)){if(V=!0,y=y.slice(0,-(k.length+7)),!y||""===y.trim())continue;if(p.some(e=>e.test(y)))continue}const w=!0===m||V;f=a($);const K=i.extract.nsSeparator??":";if(!f&&K&&y.includes(K)){const e=y.split(K);if(f=e.shift(),y=e.join(K),!y||""===y.trim())continue;if(p.some(e=>e.test(y)))continue}if(!f&&d){const e=d("t");e?.defaultNs&&(f=e.defaultNs)}if(f||(f=i.extract.defaultNS),i.extract.disablePlurals)h?u.addKey({key:`${y}_${h}`,ns:f,defaultValue:x??y}):u.addKey({key:y,ns:f,defaultValue:x??y});else if(h&&g){n(y,x??y,f,h,u,i,w);!1!==i.extract?.generateBasePluralForms&&t(y,x??y,f,u,i,w)}else h?(u.addKey({key:y,ns:f,defaultValue:x??y}),u.addKey({key:`${y}_${h}`,ns:f,defaultValue:x??y})):g?t(y,x??y,f,u,i,w):u.addKey({key:y,ns:f,defaultValue:x??y})}}}function t(e,t,n,s,a,r=!1){try{const o=r?"ordinal":"cardinal",l=new Set;for(const e of a.locales)try{const t=new Intl.PluralRules(e,{type:o});t.resolvedOptions().pluralCategories.forEach(e=>l.add(e))}catch(e){const t=new Intl.PluralRules("en",{type:o});t.resolvedOptions().pluralCategories.forEach(e=>l.add(e))}const c=Array.from(l).sort(),u=a.extract.pluralSeparator??"_";for(const a of c){const o=r?`${e}${u}ordinal${u}${a}`:`${e}${u}${a}`;s.addKey({key:o,ns:n,defaultValue:t,hasCount:!0,isOrdinal:r})}}catch(a){s.addKey({key:e,ns:n,defaultValue:t})}}function n(e,t,n,s,a,r,o=!1){try{const l=o?"ordinal":"cardinal",c=new Set;for(const e of r.locales)try{const t=new Intl.PluralRules(e,{type:l});t.resolvedOptions().pluralCategories.forEach(e=>c.add(e))}catch(e){const t=new Intl.PluralRules(r.extract.primaryLanguage||"en",{type:l});t.resolvedOptions().pluralCategories.forEach(e=>c.add(e))}const u=Array.from(c).sort(),i=r.extract.pluralSeparator??"_";for(const r of u){const l=o?`${e}_${s}${i}ordinal${i}${r}`:`${e}_${s}${i}${r}`;a.addKey({key:l,ns:n,defaultValue:t,hasCount:!0,isOrdinal:o})}}catch(r){a.addKey({key:`${e}_${s}`,ns:n,defaultValue:t})}}function s(e){const t=/^\s*,\s*(['"])(.*?)\1/.exec(e);if(t)return t[2];const n=/^\s*,\s*\{[^}]*defaultValue\s*:\s*(['"])(.*?)\1/.exec(e);return n?n[2]:void 0}function a(e){const t=/^\s*,\s*\{[^}]*ns\s*:\s*(['"])(.*?)\1/.exec(e);if(t)return t[2]}function r(e){const t=/^\s*,\s*\{[^}]*context\s*:\s*(['"])(.*?)\1/.exec(e);if(t)return t[2]}function o(e){const t=/^\s*,\s*\{[^}]*count\s*:\s*(\d+)/.exec(e);if(t)return parseInt(t[1],10)}function l(e){const t=/^\s*,\s*\{[^}]*ordinal\s*:\s*(true|false)/.exec(e);if(t)return"true"===t[1]}function c(e){const t=`^${e.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*/g,".*")}$`;return new RegExp(t)}export{e as extractKeysFromComments};
