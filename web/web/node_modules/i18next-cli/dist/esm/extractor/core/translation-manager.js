import{resolve as t,basename as e,extname as r}from"node:path";import{glob as s}from"glob";import{getNestedKeys as n,getNestedValue as o,setNestedValue as a}from"../../utils/nested-object.js";import{getOutputPath as i,loadTranslationFile as l}from"../../utils/file-utils.js";import{resolveDefaultValue as c}from"../../utils/default-value.js";function f(t){const e=`^${t.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*/g,".*")}$`;return new RegExp(e)}function u(t,e){if("object"!=typeof t||null===t||Array.isArray(t))return t;const r={},s=e?.extract?.pluralSeparator??"_",n=["zero","one","two","few","many","other"],o=n.map(t=>`ordinal${s}${t}`),a=Object.keys(t).sort((t,e)=>{const r=t=>{for(const e of o)if(t.endsWith(`${s}${e}`)){return{base:t.slice(0,-(s.length+e.length)),form:e,isOrdinal:!0,isPlural:!0,fullKey:t}}for(const e of n)if(t.endsWith(`${s}${e}`)){return{base:t.slice(0,-(s.length+e.length)),form:e,isOrdinal:!1,isPlural:!0,fullKey:t}}return{base:t,form:"",isOrdinal:!1,isPlural:!1,fullKey:t}},a=r(t),i=r(e);if(a.isPlural&&i.isPlural){const t=a.base.localeCompare(i.base,void 0,{sensitivity:"base"});if(0!==t)return t;if(a.isOrdinal!==i.isOrdinal)return a.isOrdinal?1:-1;const e=a.isOrdinal?o:n,r=e.indexOf(a.form),s=e.indexOf(i.form);return-1!==r&&-1!==s?r-s:a.form.localeCompare(i.form)}const l=t.localeCompare(e,void 0,{sensitivity:"base"});return 0===l?t.localeCompare(e,void 0,{sensitivity:"case"}):l});for(const s of a)r[s]=u(t[s],e);return r}function p(t,e,r,s,i,l=[],f=new Set,p=!1){const{keySeparator:d=".",sort:y=!0,removeUnusedKeys:g=!0,primaryLanguage:m,defaultValue:h="",pluralSeparator:x="_",contextSeparator:O="_"}=r.extract,w=new Set;try{const t=new Intl.PluralRules(s,{type:"cardinal"}),e=new Intl.PluralRules(s,{type:"ordinal"});t.resolvedOptions().pluralCategories.forEach(t=>w.add(t)),e.resolvedOptions().pluralCategories.forEach(t=>w.add(`ordinal_${t}`))}catch(t){const e=new Intl.PluralRules(m||"en",{type:"cardinal"}),r=new Intl.PluralRules(m||"en",{type:"ordinal"});e.resolvedOptions().pluralCategories.forEach(t=>w.add(t)),r.resolvedOptions().pluralCategories.forEach(t=>w.add(`ordinal_${t}`))}const S=t.filter(({key:t,hasCount:e,isOrdinal:r})=>{if(l.some(e=>e.test(t)))return!1;if(!e)return!0;const s=t.split(x);if(r&&s.includes("ordinal")){const t=s[s.length-1];return w.has(`ordinal_${t}`)}if(e){const t=s[s.length-1];return w.has(t)}return!0});let v=g?{}:JSON.parse(JSON.stringify(e));const b=n(e,d??".");for(const t of b)if(l.some(e=>e.test(t))){const r=o(e,t,d??".");a(v,t,r,d??".")}if(g){const t=n(e,d??".");for(const r of t){const t=r.split(x);if("zero"===t[t.length-1]){const s=t.slice(0,-1).join(x);if(S.some(({key:t})=>t.split(x).slice(0,-1).join(x)===s)){const t=o(e,r,d??".");a(v,r,t,d??".")}}}}for(const{key:t,defaultValue:n,explicitDefault:l}of S){const u=o(e,t,d??"."),y=!S.some(e=>e.key.startsWith(`${t}${d}`)&&e.key!==t),g="object"==typeof u&&null!==u&&(f.has(t)||!n||n===t),w="object"==typeof u&&null!==u&&y&&!f.has(t)&&!g;if(g){a(v,t,u,d??".");continue}let b;if(void 0===u||w)if(s===m)if(p){const e=n&&(n===t||t!==n&&(t.startsWith(n+x)||t.startsWith(n+O)));b=n&&!e?n:c(h,t,i||r?.extract?.defaultNS||"translation",s,n)}else b=n||t;else b=c(h,t,i||r?.extract?.defaultNS||"translation",s,n);else if(s===m&&p){const e=n&&(n===t||t!==n&&(t.startsWith(n+x)||t.startsWith(n+O)));b=(t.includes(x)||t.includes(O))&&!l?u:n&&!e?n:u}else b=u;a(v,t,b,d??".")}if(!0===y)return u(v,r);if("function"==typeof y){const t={},e=Object.keys(v),s=new Map;for(const t of S){const e=!1===d?t.key:t.key.split(d)[0];s.has(e)||s.set(e,t)}e.sort((t,e)=>{if("function"==typeof y){const r=s.get(t),n=s.get(e);if(r&&n)return y(r,n)}return t.localeCompare(e,void 0,{sensitivity:"base"})});for(const s of e)t[s]=u(v[s],r);v=t}return v}async function d(n,o,a,{syncPrimaryWithDefaults:c=!1}={}){a.extract.primaryLanguage||=a.locales[0]||"en",a.extract.secondaryLanguages||=a.locales.filter(t=>t!==a?.extract?.primaryLanguage);const u=[...a.extract.preservePatterns||[]],d=a.extract.indentation??2;for(const t of o)u.push(`${t}.*`);const y=u.map(f),g="__no_namespace__",m=new Map;for(const t of n.values()){const e=t.nsIsImplicit&&!1===a.extract.defaultNS?g:String(t.ns??a.extract.defaultNS??"translation");m.has(e)||m.set(e,[]),m.get(e).push(t)}const h=[],x=Array.isArray(a.extract.ignore)?a.extract.ignore:a.extract.ignore?[a.extract.ignore]:[];for(const n of a.locales){if(a.extract.mergeNamespaces||!a.extract.output.includes("{{namespace}}")){const e={},r=i(a.extract.output,n),s=t(process.cwd(),r),f=await l(s)||{},u=new Set([...m.keys(),...Object.keys(f)]);for(const t of u){const r=m.get(t)||[];if(t===g){const t=p(r,f,a,n,void 0,y,o,c);Object.assign(e,t)}else{const s=f[t]||{};e[t]=p(r,s,a,n,t,y,o,c)}}const x=JSON.stringify(f,null,d),O=JSON.stringify(e,null,d);h.push({path:s,updated:O!==x,newTranslations:e,existingTranslations:f})}else{const f=new Set(m.keys()),u=i(a.extract.output,n,"*"),g=await s(u,{ignore:x});for(const t of g)f.add(e(t,r(t)));for(const e of f){const r=m.get(e)||[],s=i(a.extract.output,n,e),f=t(process.cwd(),s),u=await l(f)||{},g=p(r,u,a,n,e,y,o,c),x=JSON.stringify(u,null,d),O=JSON.stringify(g,null,d);h.push({path:f,updated:O!==x,newTranslations:g,existingTranslations:u})}}}return h}export{d as getTranslations};
