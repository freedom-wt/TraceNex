"use strict";var e=require("chalk"),o=require("ora"),a=require("node:path"),t=require("./extractor/core/key-finder.js"),s=require("./utils/nested-object.js"),n=require("./utils/file-utils.js"),l=require("./utils/funnel-msg-tracker.js");function r(o,a,t){const s=t>0?Math.round(a/t*100):100,n=c(s);console.log(`${e.bold(o)}: ${n} ${s}% (${a}/${t})`)}function c(o){const a=Math.floor(o/100*20),t=20-a;return`[${e.green("".padStart(a,"â– "))}${"".padStart(t,"â–¡")}]`}async function i(){if(await l.shouldShowFunnel("status"))return console.log(e.yellow.bold("\nâœ¨ Take your localization to the next level!")),console.log("Manage translations with your team in the cloud with locize => https://www.locize.com/docs/getting-started"),console.log(`Run ${e.cyan("npx i18next-cli locize-migrate")} to get started.`),l.recordFunnelShown("status")}exports.runStatus=async function(l,u={}){l.extract.primaryLanguage||=l.locales[0]||"en",l.extract.secondaryLanguages||=l.locales.filter(e=>e!==l?.extract?.primaryLanguage);const y=o("Analyzing project localization status...\n").start();try{const o=await async function(e){e.extract.primaryLanguage||=e.locales[0]||"en",e.extract.secondaryLanguages||=e.locales.filter(o=>o!==e?.extract?.primaryLanguage);const{allKeys:o}=await t.findKeys(e),{secondaryLanguages:l,keySeparator:r=".",defaultNS:c="translation",mergeNamespaces:i=!1,pluralSeparator:u="_"}=e.extract,y=new Map;for(const e of o.values()){const o=e.ns||c||"translation";y.has(o)||y.set(o,[]),y.get(o).push(e)}const d={totalBaseKeys:o.size,keysByNs:y,locales:new Map};for(const o of l){let t=0,l=0;const c=new Map,g=i?await n.loadTranslationFile(a.resolve(process.cwd(),n.getOutputPath(e.extract.output,o)))||{}:null;for(const[d,f]of y.entries()){const y=i?g?.[d]||{}:await n.loadTranslationFile(a.resolve(process.cwd(),n.getOutputPath(e.extract.output,o,d)))||{};let p=0,$=0;const m=[];for(const{key:e,hasCount:a,isOrdinal:t}of f)if(a){const a=t?"ordinal":"cardinal",n=new Intl.PluralRules(o,{type:a}).resolvedOptions().pluralCategories;for(const o of n){$++;const a=t?`${e}${u}ordinal${u}${o}`:`${e}${u}${o}`,n=!!s.getNestedValue(y,a,r??".");n&&p++,m.push({key:a,isTranslated:n})}}else{$++;const o=!!s.getNestedValue(y,e,r??".");o&&p++,m.push({key:e,isTranslated:o})}c.set(d,{totalKeys:$,translatedKeys:p,keyDetails:m}),t+=p,l+=$}d.locales.set(o,{totalKeys:l,totalTranslated:t,namespaces:c})}return d}(l);y.succeed("Analysis complete."),await async function(o,a,t){t.detail?await async function(o,a,t,s){if(t===a.extract.primaryLanguage)return void console.log(e.yellow(`Locale "${t}" is the primary language. All keys are considered present.`));if(!a.locales.includes(t))return void console.error(e.red(`Error: Locale "${t}" is not defined in your configuration.`));const n=o.locales.get(t);if(!n)return void console.error(e.red(`Error: Locale "${t}" is not a valid secondary language.`));console.log(e.bold(`\nKey Status for "${e.cyan(t)}":`));const l=Array.from(o.keysByNs.values()).flat().length;r("Overall",n.totalTranslated,n.totalKeys);const c=s?[s]:Array.from(n.namespaces.keys()).sort();for(const o of c){const a=n.namespaces.get(o);a&&(console.log(e.cyan.bold(`\nNamespace: ${o}`)),r("Namespace Progress",a.translatedKeys,a.totalKeys),a.keyDetails.forEach(({key:o,isTranslated:a})=>{const t=a?e.green("âœ“"):e.red("âœ—");console.log(`  ${t} ${o}`)}))}const u=l-n.totalTranslated;u>0?console.log(e.yellow.bold(`\nSummary: Found ${u} missing translations for "${t}".`)):console.log(e.green.bold(`\nSummary: ðŸŽ‰ All keys are translated for "${t}".`));await i()}(o,a,t.detail,t.namespace):t.namespace?await async function(o,a,t){const s=o.keysByNs.get(t);if(!s)return void console.error(e.red(`Error: Namespace "${t}" was not found in your source code.`));console.log(e.cyan.bold(`\nStatus for Namespace: "${t}"`)),console.log("------------------------");for(const[e,a]of o.locales.entries()){const o=a.namespaces.get(t);if(o){const a=o.totalKeys>0?Math.round(o.translatedKeys/o.totalKeys*100):100,t=c(a);console.log(`- ${e}: ${t} ${a}% (${o.translatedKeys}/${o.totalKeys} keys)`)}}await i()}(o,0,t.namespace):await async function(o,a){const{primaryLanguage:t}=a.extract;console.log(e.cyan.bold("\ni18next Project Status")),console.log("------------------------"),console.log(`ðŸ”‘ Keys Found:         ${e.bold(o.totalBaseKeys)}`),console.log(`ðŸ“š Namespaces Found:   ${e.bold(o.keysByNs.size)}`),console.log(`ðŸŒ Locales:            ${e.bold(a.locales.join(", "))}`),console.log(`âœ… Primary Language:   ${e.bold(t)}`),console.log("\nTranslation Progress:");for(const[e,a]of o.locales.entries()){const o=a.totalKeys>0?Math.round(a.totalTranslated/a.totalKeys*100):100,t=c(o);console.log(`- ${e}: ${t} ${o}% (${a.totalTranslated}/${a.totalKeys} keys)`)}await i()}(o,a)}(o,l,u)}catch(e){y.fail("Failed to generate status report."),console.error(e)}};
