"use strict";var e=require("glob"),t=require("node:fs/promises"),n=require("@swc/core"),r=require("chalk"),o=require("ora");const s=e=>/^(https|http|\/\/|^\/)/.test(e);function i(e,t,n){const r=[],o=[],i=e=>t.substring(0,e).split("\n").length,a=n.extract.transComponents||["Trans"],l=n.extract.ignoredTags||[],c=new Set([...a,"script","style","code",...l]),u=n.extract.ignoredAttributes||[],f=new Set(["className","key","id","style","href","i18nKey","defaults","type","target",...u]),p=e=>{if(!e)return null;const t=e.name??e.opening?.name??e.opening?.name;if(!t)return e.opening?.name?p({name:e.opening.name}):null;const n=e=>{if(!e)return null;if("JSXIdentifier"===e.type&&(e.name||e.value))return e.name??e.value;if("Identifier"===e.type&&(e.name||e.value))return e.name??e.value;if("JSXMemberExpression"===e.type){const t=n(e.object),r=n(e.property);return t&&r?`${t}.${r}`:r??t}return e.name??e.value??e.property?.name??e.property?.value??null};return n(t)},g=e=>{for(let t=e.length-1;t>=0;t--){const n=e[t];if(n&&"object"==typeof n&&("JSXElement"===n.type||"JSXOpeningElement"===n.type||"JSXSelfClosingElement"===n.type)){const e=p(n);if(e&&c.has(e))return!0}}return!1},y=(e,t)=>{if(!e||"object"!=typeof e)return;const n=[...t,e];if("JSXText"===e.type){if(!g(n)){const t=e.value.trim();t&&t.length>1&&"..."!==t&&!s(t)&&isNaN(Number(t))&&!t.startsWith("{{")&&o.push(e)}}if("StringLiteral"===e.type){const t=n[n.length-2],r=g(n);if("JSXAttribute"===t?.type&&!f.has(t.name.value)&&!r){const t=e.value.trim();t&&"..."!==t&&!s(t)&&isNaN(Number(t))&&o.push(e)}}for(const t of Object.keys(e)){if("span"===t)continue;const r=e[t];Array.isArray(r)?r.forEach(e=>y(e,n)):r&&"object"==typeof r&&y(r,n)}};y(e,[]);let d=0;for(const e of o){const n=e.raw??e.value,o=t.indexOf(n,d);o>-1&&(r.push({text:e.value.trim(),line:i(o)}),d=o+n.length)}return r}exports.runLinter=async function(s){const a=o("Analyzing source files...\n").start();try{const o=["node_modules/**"],l=Array.isArray(s.extract.ignore)?s.extract.ignore:s.extract.ignore?[s.extract.ignore]:[],c=await e.glob(s.extract.input,{ignore:[...o,...l]});let u=0;const f=new Map;for(const e of c){const r=await t.readFile(e,"utf-8"),o=i(await n.parse(r,{syntax:"typescript",tsx:!0,decorators:!0}),r,s);o.length>0&&(u+=o.length,f.set(e,o))}if(u>0){a.fail(r.red.bold(`Linter found ${u} potential issues.`));for(const[e,t]of f.entries())console.log(r.yellow(`\n${e}`)),t.forEach(({text:e,line:t})=>{console.log(`  ${r.gray(`${t}:`)} ${r.red("Error:")} Found hardcoded string: "${e}"`)});process.exit(1)}else a.succeed(r.green.bold("No issues found."))}catch(e){a.fail(r.red("Linter failed to run.")),console.error(e),process.exit(1)}};
