import mergeResources from './mergeResources.js';

function mergeResourcesAsInterface(namespaces) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let resources = mergeResources(namespaces);
  let interfaceFileContent = 'interface Resources ';
  if (options.optimize) {
    resources = groupPluralKeys(Object.entries(resources), options);
  }
  interfaceFileContent += resourceToString(resources);
  interfaceFileContent += '\n\nexport default Resources;\n';
  return interfaceFileContent;
}
function resourceToString(resources) {
  let indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const intend = '  '.repeat(indentation);
  if (typeof resources === 'string') return JSON.stringify(resources);
  if (Array.isArray(resources)) {
    return `[${resources.map(it => resourceToString(it)).join(', ')}]`;
  }
  if (resources && '_tag' in resources && resources._tag === translationSymbol) {
    return resources.value.map(it => JSON.stringify(it)).join(' | ');
  }
  if (typeof resources === 'object' && resources !== null) {
    const entries = Object.entries(resources).sort((_ref, _ref2) => {
      let [k1] = _ref;
      let [k2] = _ref2;
      if (k1 < k2) return -1;
      if (k1 > k2) return 1;
      return 0;
    }).map(_ref3 => {
      let [k, v] = _ref3;
      return `"${k.replace(/"/g, '\\"')}": ${resourceToString(v, indentation + 1)}`;
    });
    return `{\n${entries.map(it => `${intend}  ${it}`).join(',\n')}\n${intend}}`;
  }
}
const isPluralKey = (key, _ref4) => {
  let {
    pluralSeparator = defaultOptions.pluralSeparator
  } = _ref4;
  return pluralSuffixes.map(suffix => `${pluralSeparator}${suffix}`).some(suffix => key.endsWith(suffix));
};
const defaultOptions = {
  pluralSeparator: '_'
};
const pluralSuffixes = ['zero', 'one', 'two', 'few', 'many', 'other'];
const isPluralEntry = options => entry => isPluralKey(entry[0], options);
function rmPluralization(entry, options) {
  if (!isPluralEntry(options)(entry)) return null;else {
    const [key] = entry;
    const index = key.lastIndexOf(options.pluralSeparator ?? defaultOptions.pluralSeparator);
    return key.slice(0, index);
  }
}
const translationSymbol = Symbol('is-translation');
function groupPluralKeys(entries, options) {
  if (typeof entries === 'string') return entries;
  if (entries.length === 0) return {};
  return entries.reduce((acc, _ref5) => {
    let [k, v] = _ref5;
    if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
      acc[k] = groupPluralKeys(Object.entries(v), options);
      return acc;
    }
    if (Array.isArray(v)) {
      acc[k] = v.map(item => {
        if (typeof item === 'object' && item !== null) {
          return groupPluralKeys(Object.entries(item), options);
        }
        return item;
      });
      return acc;
    }
    const maybe = rmPluralization([k, v], options);
    if (maybe == null) {
      acc[k] = {
        _tag: translationSymbol,
        value: [v]
      };
      return acc;
    }
    const depluralized = maybe;
    if (depluralized in acc) {
      const existing = acc[depluralized];
      acc[depluralized] = {
        _tag: translationSymbol,
        value: [...existing.value, v]
      };
      return acc;
    } else {
      acc[depluralized] = {
        _tag: translationSymbol,
        value: [v]
      };
      return acc;
    }
  }, {});
}

export { mergeResourcesAsInterface as default, defaultOptions, groupPluralKeys, pluralSuffixes, rmPluralization };
