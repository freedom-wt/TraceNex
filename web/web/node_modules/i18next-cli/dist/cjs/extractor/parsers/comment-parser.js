"use strict";function e(e,t,n,s,a,r=!1){try{const o=r?"ordinal":"cardinal",l=new Set;for(const e of a.locales)try{const t=new Intl.PluralRules(e,{type:o});t.resolvedOptions().pluralCategories.forEach(e=>l.add(e))}catch(e){const t=new Intl.PluralRules("en",{type:o});t.resolvedOptions().pluralCategories.forEach(e=>l.add(e))}const c=Array.from(l).sort(),u=a.extract.pluralSeparator??"_";for(const a of c){const o=r?`${e}${u}ordinal${u}${a}`:`${e}${u}${a}`;s.addKey({key:o,ns:n,defaultValue:t,hasCount:!0,isOrdinal:r})}}catch(a){s.addKey({key:e,ns:n,defaultValue:t})}}function t(e,t,n,s,a,r,o=!1){try{const l=o?"ordinal":"cardinal",c=new Set;for(const e of r.locales)try{const t=new Intl.PluralRules(e,{type:l});t.resolvedOptions().pluralCategories.forEach(e=>c.add(e))}catch(e){const t=new Intl.PluralRules(r.extract.primaryLanguage||"en",{type:l});t.resolvedOptions().pluralCategories.forEach(e=>c.add(e))}const u=Array.from(c).sort(),i=r.extract.pluralSeparator??"_";for(const r of u){const l=o?`${e}_${s}${i}ordinal${i}${r}`:`${e}_${s}${i}${r}`;a.addKey({key:l,ns:n,defaultValue:t,hasCount:!0,isOrdinal:o})}}catch(r){a.addKey({key:`${e}_${s}`,ns:n,defaultValue:t})}}function n(e){const t=/^\s*,\s*(['"])(.*?)\1/.exec(e);if(t)return t[2];const n=/^\s*,\s*\{[^}]*defaultValue\s*:\s*(['"])(.*?)\1/.exec(e);return n?n[2]:void 0}function s(e){const t=/^\s*,\s*\{[^}]*ns\s*:\s*(['"])(.*?)\1/.exec(e);if(t)return t[2]}function a(e){const t=/^\s*,\s*\{[^}]*context\s*:\s*(['"])(.*?)\1/.exec(e);if(t)return t[2]}function r(e){const t=/^\s*,\s*\{[^}]*count\s*:\s*(\d+)/.exec(e);if(t)return parseInt(t[1],10)}function o(e){const t=/^\s*,\s*\{[^}]*ordinal\s*:\s*(true|false)/.exec(e);if(t)return"true"===t[1]}function l(e){const t=`^${e.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*/g,".*")}$`;return new RegExp(t)}exports.extractKeysFromComments=function(c,u,i,d){const f=new RegExp("\\bt\\s*\\(\\s*(['\"])([^'\"]+)\\1","g"),p=(i.extract.preservePatterns||[]).map(l),y=function(e){const t=[],n=new Set,s=/\/\/(.*)|\/\*([\s\S]*?)\*\//g;let a;for(;null!==(a=s.exec(e));){const e=(a[1]??a[2]).trim();e&&!n.has(e)&&(n.add(e),t.push(e))}return t}(c);for(const l of y){let c;for(;null!==(c=f.exec(l));){let f,y=c[2];if(!y||""===y.trim())continue;if(p.some(e=>e.test(y)))continue;const $=l.slice(c.index+c[0].length),x=n($),h=a($),g=r($),m=o($);let K=!1;const V=i.extract.pluralSeparator??"_";if(y.endsWith(`${V}ordinal`)){if(K=!0,y=y.slice(0,-(V.length+7)),!y||""===y.trim())continue;if(p.some(e=>e.test(y)))continue}const k=!0===m||K;f=s($);const w=i.extract.nsSeparator??":";if(!f&&w&&y.includes(w)){const e=y.split(w);if(f=e.shift(),y=e.join(w),!y||""===y.trim())continue;if(p.some(e=>e.test(y)))continue}if(!f&&d){const e=d("t");e?.defaultNs&&(f=e.defaultNs)}if(f||(f=i.extract.defaultNS),i.extract.disablePlurals)h?u.addKey({key:`${y}_${h}`,ns:f,defaultValue:x??y}):u.addKey({key:y,ns:f,defaultValue:x??y});else if(h&&g){t(y,x??y,f,h,u,i,k);!1!==i.extract?.generateBasePluralForms&&e(y,x??y,f,u,i,k)}else h?(u.addKey({key:y,ns:f,defaultValue:x??y}),u.addKey({key:`${y}_${h}`,ns:f,defaultValue:x??y})):g?e(y,x??y,f,u,i,k):u.addKey({key:y,ns:f,defaultValue:x??y})}}};
